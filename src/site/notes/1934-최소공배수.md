---
{"dg-publish":true,"permalink":"/1934-최소공배수/","tags":["PS","유클리드호제법"],"created":"2024-02-16T15:05:05.688+09:00","updated":"2024-02-16T15:53:50.608+09:00"}
---


# 최소공배수

> 문제 번호: 1934
> 문제 난이도 (solved.ac 기준): 브론즈 I
> 기간: 2023년 2월 16일 (Python)
> 비고: 시간 초과 1
---

## 무슨 문제인가?

https://www.acmicpc.net/problem/1934
테스트 케이스의 개수 T, 케이스 하나 당 두 개의 자연수 A, B가 입력될 때 둘의 최소공배수를 구하는 문제다.
+ 1 ≤ T ≤ 1,000
+ 1 ≤ A, B ≤ 45,000

## 1차 시도 (시간 초과)

```Python

# 테스트 케이스의 개수 T 입력
t = int(input())

for i in range(t):
  # a와 b 입력
  a, b = map(int, input().split(' '))

  # 둘 중 큰 수를 2배, 3배, ... 계속 늘리면서 작은 수로 나눠보고, 나머지가 없으면 공배수
  x = max(a, b)
  y = min(a, b)
  r = x

  # 가장 먼저 나타나는 공배수가 최소공배수
  while r%y != 0:
    r += x
  
  # 최소공배수 출력
  print(r)

```

### 아이디어

둘 중 큰 수를 2배, 3배, ... 계속 늘리면서 작은 수로 나눠봤을 때, 나머지가 없는 최초의 수가 최소공배수.

### 시간 초과

시간 초과는 일반적으로 알고리즘이 비효율적일 때 발생한다고 생각하면 된다. 정확히는 채점에 사용된 데이터를 나의 풀이가 소화하지 못할 때 발생하는데, 보통은 그게 그거다. 그러나, 데이터가 알고리즘의 효율성을 충분히 검증해내지 못하면 알고리즘이 최적이 아니어도 통과되기도 한다. 그럴 때는 맞아도 마음 한구석이 찜찜하다. 이번에는 나의 풀이가 큰 데이터 (ex. A = 43999, B = 44000)를 소화하지 못한 경우다.

## 2차 시도 (성공)

```Python

# 테스트 케이스의 개수 T 입력
t = int(input())

for i in range(t):
  # a와 b 입력
  a, b = map(int, input().split(' '))

  # 둘 중 큰 수를 2배, 3배, ... 계속 늘리면서 작은 수로 나눠보고, 나머지가 없으면 공배수
  x = max(a, b)
  y = min(a, b)

  # 유클리드 호제법으로 최대공약수 구하기
  while x%y != 0:
    x, y = y, x%y

  # y가 최대공약수 -> ab를 y로 나누면 최소공배수가 나온다.
  print(a*b//y)

```

### 아이디어

이번에 사용된 아이디어는 최대공약수를 구하기 위한 유클리드 호제법, 그리고 최소공배수를 구하기 위해 최대공약수를 이용하는 방법이다.

#### 유클리드 호제법

유클리드 호제법은 둘 중 큰 수를 작은 수로 나눈 다음, 큰 수를 작은 수로 대체하고 작은 수를 이때 나온 나머지로 대체하는 과정을 반복해 나머지가 0이 되면 멈춘다[^1].

[^1]: https://ko.wikipedia.org/wiki/유클리드_호제법 | 자세한 설명은 링크를 참고 바람.

#### 최소공배수 구하기

$$
\begin{matrix}
    A \times B = gcd(A, B) \times lcm(A, B)\\
    \text{gcd(A, B): A와 B의 최대공약수} \\
    \text{lcm(A, B): A와 B의 최소공배수}
\end{matrix}
$$

최소공배수의 성질을 이용한 이 식의 원리는 링크를 참고 바람[^2].

[^2]: https://ko.wikipedia.org/wiki/최소공배수